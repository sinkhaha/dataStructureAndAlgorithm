## 题目
**924. 尽量减少恶意软件的传播**
>困难

在节点网络中，只有当 `graph[i][j] = 1` 时，每个节点 i 能够直接连接到另一个节点 j。

一些节点 `initial` 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设 `M(initial)` 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。

我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 `M(initial)`， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。

请注意，如果某个节点已从受感染节点的列表 `initial` 中删除，它以后可能仍然因恶意软件传播而受到感染。

 

示例 1：
```
输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
输出：0
```
示例 2：
```
输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
输出：0
```
示例 3：
```
输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
输出：1
```

提示：

* 1 < graph.length = graph[0].length <= 300
* `0 <= graph[i][j] == graph[j][i] <= 1`
* `graph[i][i] == 1`
* 1 <= initial.length < graph.length
* 0 <= initial[i] < graph.length

>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimize-malware-spread
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 解法：并查集
### 思路
* 建立并查集，记录每个不交集的节点数
* 每次删除initial一个节点，然后计算此时的感染节点数，找到最小感染数和对应的节点索引即可

### 代码
```js
/**
 * 并查集类
 */
class UnionFind {
    constructor(size) {
        // 初始化数组，其值为其索引值
        this.parents = Array(size)
            .fill(0)
            .map((_, i) => i);
        this.sizes = Array(size).fill(1);
    }

    /**
     * 返回某个节点x的根节点
     */
    find(x) {
        if (x !== this.parents[x]) {
            this.parents[x] = this.find(this.parents[x]);
        }
        return this.parents[x];
    }

    /**
     * 获取所在集合的大小
     */
    getSize(x) {
        return this.sizes[this.find(x)];
    }

    /**
     * 连接
     */
    union(a, b) {
        const fa = this.find(a);
        const fb = this.find(b);
        if (fa == fb) {
            return;
        }

        if (this.sizes[fa] < this.sizes[fb]) {
            this.parents[fa] = fb;
            // fb是root
            this.sizes[fb] += this.sizes[fa];
        } else {
            this.parents[fb] = fa;
            // fa是root
            this.sizes[fa] += this.sizes[fb];
        }

    }
}

/* ============================================================= */
/**
 * 
 * @param {*} graph 
 * @param {*} initial 
 */
var minMalwareSpread = function (graph, initial) {
    const uf = new UnionFind(graph.length);
    // 根据graph构建uf
    for (let i = 0; i < graph.length; i++) {
        for (let j = 0; j < graph.length; j++) {
            graph[i][j] === 1 && uf.union(i, j);
        }
    }

    let minNumbers = Infinity, minIndex = initial[0];
    for (let i = 0; i < initial.length; i++) {
        // 把第i个节点去掉，然后计算感染节点数
        let temNumbers = getInfectedNumbers([
            ...initial.slice(0, i),
            ...initial.slice(i + 1)
        ]);
        
        // 如果感染人数更少，更新结果minIndex
        if (minNumbers > temNumbers) {
            minIndex = initial[i];
            minNumbers = temNumbers;
        // 如果感染人数一样，则取索引值更小的
        } else if (minNumbers === temNumbers && minIndex > initial[i]) {
            minIndex = initial[i];
        }
    }
    return minIndex;

    /**
     * 根据inital 和 uf 计算感染节点数
     */
    function getInfectedNumbers(initial) {
        // 去重
        const roots = [];
        for (let i = 0; i < initial.length; i++) {
            const p = uf.find(initial[i]);
            roots.includes(p) || roots.push(p);
        }

        return roots.reduce((prev, curr) => prev + uf.getSize(curr), 0);
    }
};
```
### 复杂度
* 时间复杂度：O(n^2)
* 空间复杂度：O(n)
