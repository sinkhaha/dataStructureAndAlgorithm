## 题目
**688. “马”在棋盘上的概率**
>中等

已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。 

现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 

如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。

现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。

求移动结束后，“马” 仍留在棋盘上的概率。

 

示例：
```
输入: 3, 2, 0, 0
输出: 0.0625
解释: 
输入的数据依次为 N, K, r, c
第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。
所以 “马” 在结束后仍在棋盘上的概率为 0.0625。
```

注意：

* N 的取值范围为 [1, 25]
* K 的取值范围为 [0, 100]
* 开始时，“马” 总是位于棋盘上


>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/knight-probability-in-chessboard
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 解法：动态规划
### 思路
多状态的转移

以下参考自官方题解
* `f[r][c][steps]` 代表马在位置` (r, c)` 移动了 steps 次以后还留在棋盘上的概率

* 根据马的移动方式，有以下递归：
```js
for (let k = 0; k < 8; k++) { 
   f[r][c][steps] += f[r+dr[k]][c+dc[k]][steps-1] / 8.0
}
```

* 根据题目可以知道 `(dr, dc) `的可能数据对是 `(2, 1), (2,1), (2, -1),(2,−1), (-2, 1),(−2,1), (-2, -1),(−2,−1), (1, 2),(1,2), (1, -2),(1,−2), (-1, 2),(−1,2), (-1, -2)(−1,−2)`

* 使用二维的 dp 和 dp2 来存储我们的数据，而不是使用三维数组 f

  `dp 代表 f[][][steps-1]`

  `dp2 代表 f[][][steps]`

---

1. dp数组
`dp[i][j]`表示：马从最初的棋盘内位置`(r, c)`移动到目前棋盘内位置`(i , j)`的概率

2. 用两个dp数组，dp记录当前概率，dp2记录移动一次以后的概率

3. 状态转移方程`dp2[x][y] += dp[i][j] / 8`
> (x, y) 是移动后位置，(i, j) 是移动前位置，即 (i, j) 有1/8的概率移动到 (x, y)

4. 最后计算dp数组的总和即可



### 代码
```js
/**
 * 
 * @param {number} N
 * @param {number} K
 * @param {number} r
 * @param {number} c
 * @return {number}
 */
var knightProbability = function (N, K, r, c) {
    // 方向数组
    let direction = [[-1, -2], [-2, -1], [2, 1], [1, 2], [-1, 2], [-2, 1], [1, -2], [2, -1]];

    let dp = Array.from(Array(N), () => Array(N).fill(0));
    dp[r][c] = 1;

    for (; K > 0; K--) {
        let dp2 = Array.from(Array(N), () => Array(N).fill(0));
        for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
                for (let k = 0; k < 8; k++) {
                    let cr = r + direction[k][0];
                    let cc = c + direction[k][1];
                    if (0 <= cr && cr < N && 0 <= cc && cc < N) {
                        dp2[cr][cc] += dp[r][c] / 8.0;
                    }
                }
            }
        }
        dp = dp2;
    }


    let ans = 0;
    for (let row of dp) {
        for (let x of row) {
            ans += x;
        }
    }

    return ans;
}; 
```
### 复杂度
* 时间复杂度：O(N * N * K)
* 空间复杂度：O(N * N)