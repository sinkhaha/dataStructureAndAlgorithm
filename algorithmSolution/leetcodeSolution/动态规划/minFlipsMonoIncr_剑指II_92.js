/**
 * 剑指 Offer II 092. 翻转字符
 * 中等
 * https://leetcode.cn/problems/cyJERH/
 * 
 * 解法：动态规划
 * 
 * 时间O(n) 
 * 空间O(1)
 */
/**
 * @param {string} s
 * @return {number}
 */
var minFlipsMonoIncr = function (s) {
    // 由题目可知，首字符可以是0或1；其余的每个字符，如果当前字符是0，那前面的字符一定是0，如果当前是1，那前面可以是0也可以是1

    // 动态规划
    // 由于字符串 s 的每个位置的字符可以是 0 或 1，因此对于每个位置需要分别计算该位置的字符是 0 和该位置的字符是 1 的情况下的最小翻转次数
    // 假设字符串s的长度是n，对于0 <= i < n，用dp[i][0]和dp[i][1] 分别表示下标 i 处的字符为 0 和 1 的情况下使得s[0..i] 单调递增的最小翻转次数

    // 当i=0时，dp[0][0]和dp[0][1]取决于s[0]的值。当s[0]为1时，dp[0][0]=1，dp[0][1]=0;当s[0]为0时，dp[0][0]=0，dp[0][1]=1

    // 当 1 <= i < n 时，考虑下标 i 处的字符。如果下标 i 处的字符是 0，则只有当下标 i−1 处的字符是 0 时才符合单调递增；如果下标 i 处的字符是 1，则下标 i−1 处的字符是 0 或 1 都符合单调递增，此时为了将翻转次数最小化，应分别考虑下标 i−1 处的字符是 0 和 1 的情况下需要的翻转次数，取两者的最小值。
    // 状态转移方程
    // 当s[i]为0， dp[i][0] = dp[i-1][0]；dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + 1
    // 当s[i]为1， dp[i][0] = dp[i-1][0] + 1；dp[i][1] = min(dp[i-1][0], dp[i-1][1])

    // 最后dp[n−1][0] 和 dp[n−1][1] 中的最小值即为使字符串 s 单调递增的最小翻转次数。
    // base case ，dp[−1][0]=dp[−1][1]=0

    // 状态压缩
    const n = s.length;
    let dp0 = 0;
    let dp1 = 0;
    for (let i = 0; i < n; i++) {
        const c = s[i];
        let dp0New = dp0;
        let dp1New = Math.min(dp0, dp1);
        if (c === '1') {
            dp0New++;
        } else {
            dp1New++;
        }
        dp0 = dp0New;
        dp1 = dp1New;
    }
    return Math.min(dp0, dp1);
};