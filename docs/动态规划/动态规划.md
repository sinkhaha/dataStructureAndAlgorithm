### 动态规划问题
* 动态规划问题一般是`求最值`
> 比如求最小编辑距离
* 求解的核心是`穷举`(空间换时间)，根据状态转移方程正确的穷举
* 一般能用动态规划解决的问题，都可以使用回溯算法的暴力穷举解决
>所以一般可以先尝试用递归(带备忘录的递归)求解，画出递归树，再根据规律尝试用迭代(dp数组)的动态规划解法优化
>
>动态规划一般是自底向上，而递归一般是自顶向下

### 动态规划问题3要素
* 存在重叠子问题
>不同的阶段的选择，会产生重复的状态，可以用备忘录或dp表格优化重叠子问题
* 存在最优子结构
>由 `子问题的最优解` 可以推导求出 `原问题的最优解`，找`最优⼦结构`的过程，其实就是证明状态转移⽅程正确性的过程，也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来，前面的状态一旦确定，就不会受到后面的选择影响
* 状态转移方程（核心难点）

### 解题4步骤
* 明确`状态`
>即原问题和子问题中会变化的变量
* 明确`选择`
>即导致`状态`产生变化的行为
* 定义`dp数组` 或 `dp函数` 的含义
>一般来说函数的参数就是状态转移中会变化的量，即`状态`；函数的返回值就是题目要求我们计算的结果
* 找状态之间的关系(状态转移方程)，明确基础情况 base case 


### 遍历代码模板
```
// 基础情况，即根据状态定义时就已知的情况
dp[0][0][...] = base
// 选择，发生状态的转移，由已知推出未知
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
          ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

### dp数组的遍历方向的选择(⼆维dp数组来举例)

#### 遍历方向的选择
1. 遍历的过程中，需要用到的`状态`是已经计算出来的，即根据已知的结果计算出未知的结果
2. 遍历的`终点`一般存储了问题要求的`解`

##### 正向遍历

`dp[0][...]`和`dp[...][0]`是已知的值即base case，所求结果为`dp[i][j]`，`dp[i][j]可以正着遍历由dp[i-1][j-1]和dp[i][j-1]和dp[i-1][j]`求出来

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%AD%A3%E7%9D%80%E9%81%8D%E5%8E%86drawio.png)

```javascript
let dp = [[...], [...]...]; // m行，n列
for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
        // 根据状态转移方程计算出 dp[i][j]
    }
}
```
##### 倒着遍历

```javascript
let dp = [[...], [...]...]; // m行，n列
for (let i = m - 1; i >= 0; i--) {
    for (let j = n - 1; j >= 0; j--) {
        // 根据状态转移方程计算出 dp[i][j]
    }
}
    
```
##### 斜着遍历

对角线`dp[0][0]`和`dp[1][1]....dp[m][n]`是已知的值即base case，所求结果为`dp[0][n]`，需要斜着遍历，可以从下向上从左到右遍历

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/leetcode/%E5%80%92%E7%9D%80%E9%81%8D%E5%8E%86.png)

```javascript
// 斜着遍历数组 
let dp = [[...], [...]...]; // m行，n列
for (let l = 2; l <= n; l++) {
    for (let i = 0; i <= n - l; i++) {
        let j = l + i - 1;
        // 根据状态转移方程计算出 dp[i][j]
    } 
}

// 如果，m等于n，则
let dp = [[...], [...]...]; // m行，n列
for (let i = m - 1; i >= 0; i--) {
    for (let j = i + 1; j <= m; j++) {
        // 根据状态转移方程计算出 dp[i][j]
    } 
}
```
