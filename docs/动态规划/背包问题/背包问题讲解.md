# 0-1背包
## 什么是0-1背包问题
有一个可装载重量为W的背包 和 N个物品，每个物品有重量wt和价值val两个属性。
其中第i个物品的重量为wt[i]，价值为val[i]，现在用这个背包装物品，每个物品只能使用一次，能装的最大价值是多少？

**0-1背包问题指的是每个物品只能使用一次**

```
例如：
N = 3, W = 4
wt = [2, 1, 3], val = [4, 2, 3]
结果：返回 6，表示选择前2件物品装进背包，总重量3小于W，可以获得最大价值6
```

## 解题思路
1. 状态：随着 背包的容量 和 可选的物品 的不同，`dp[i][w]`最大价值也不同
2. 选择：把物品装进背包 或 不把物品装进背包
3. dp数组定义：
`dp[i][w]`:  表示对于前i个物品，当前背包的容量为w，这时可以装的最大价值是`dp[i][w]`，
根据定义所求结果就是`dp[N][W]`

4. 状态转移方程
可以选择把物品装进背包 或 不把物品装进背包（每件物品只能选择一次）
* 如果没有把第i个物品装入背包，最大价值`dp[i][w] = dp[i-1][w]` (没有装即跟前一个结果相等)
* 如果把第i个物品装入背包，那么`dp[i][w] = dp[i-1][w-wt[i-1]] + val[i-1]` (由于i是从 1 开始的，所以对val和wt的取值是i-1，`w-wt[i-1]`为选择i后剩余的背包能装下的重量，`val[i-1]`为当前选择i的价值)

5. 基础情况base case
`dp[0][..] = dp[..][0] = 0`，因为没有物品 或 背包没有空间时，能装的最大价值是0

## 代码
```javascript
/**
 * 
 * 时间复杂度O(NW)
 * 空间复杂度O(NW)
 * 
 * @param {*} N 物品数
 * @param {*} W 背包重量
 * @param {*} wt 各个物品的重量
 * @param {*} val 各个物品的价值
 */
function zeroOneBag(N, W, wt, val) {
    // 初始化N+1行，W+1列的二维数组为0，此时已经包含base case
    let dp = Array.from(Array(N+1), () => Array(W+1).fill(0));
    
    console.log(dp);

    // 从左往右，从上往下遍历即可
    // 做选择，选择物品装不装入背包
    for (let i = 1; i < N + 1; i++) {
        for (let w = 1; w < W + 1; w++) {
            // 当前背包容量不够时，物品只能不装入背包
            if (w - wt[i - 1] < 0) {
                dp[i][w] =  dp[i - 1][w];
            } else {
                // 当前背包重量够，可以选择装与不装
                dp[i][w] = Math.max(
                    dp[i - 1][w], // 不装
                    dp[i - 1][w - wt[i - 1]] + val[i - 1] // 装
                );
            }
        }
    }

    return dp[N][W];
}

const N = 3;
const W = 4;
const wt = [2, 1, 3];
const val = [4, 2, 3];
console.log(zeroOneBag(N, W, wt, val)); // 6
```

# 完全背包
## 什么是完全背包
有一个可装载重量为W的背包 和 N个物品，每个物品有重量wt和价值val两个属性。
其中第i个物品的重量为wt[i]，价值为val[i]，现在用这个背包装物品，每件物品可以选择无限次，能装的最大价值是多少？

**完全背包问题指的是每个物品可以使用无限次**

```
例如：
N = 3, W = 4
wt = [2, 1, 3], val = [4, 2, 3]
```

## 解题思路
1. 状态：随着 背包的容量 和 可选的物品 的不同，`dp[i][w]`最大价值也不同

2. 选择：把物品装进背包 或 不把物品装进背包

3. dp数组
`dp[i][w]`：表示对于前i个物品，当前背包的容量为w，这时可以装的最大价值是`dp[i][w]`

4. 状态转移方程

  可以选择把物品装进背包 或 不把物品装进背包（每件物品可以选择无数次）
* 不把第i件物品放入背包，则`dp[i][w] = dp[i-1][w]`，这跟0-1背包一样。
* 把第i件物品放入背包，则`dp[i][w] = dp[i][w-wt[i]]`，因为每种物品可以无数件（注意有容量的限制，所以还是有限的），放了第i件物品后还可以继续放第i件物品，直到`w-wt[i]`无法大于等于0为止

>注意：把第i件物品放入背包的处理和01背包不同；
因为0-1背包的每个物品只能选择一个，因此选择放第i件物品意味着转移到`dp[i][w] = dp[i-1][w-wt[i]]`这个状态；完全背包如果选择放第i件物品之后并不是转移到`dp[i-1][w-wt[i]]`这个状态；而是转移到`dp[i][w-wt[i]]`，放了第i件物品后还可以继续放第i件物品，所以`dp[i][w] = dp[i][w-wt[i]]`

5. 基础情况base case
   `dp[0][..] = dp[..][0] = 0`，因为没有物品 或 背包没有空间时，能装的最大价值是0

## 代码
```avascript
// 完全背包的一维形式代码如下所示
for(let i = 1 ; i <= N; i++){
    // 正向枚举v
    for(let w = wt[i]; w <= W ; w++) {
        dp[w] = Math.max(dp[w], dp[w-wt[i]] + val[i]);
    }
}
```
